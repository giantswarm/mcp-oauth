# MCP 2025-11-25 Specification Guide

This guide explains the new features introduced in the MCP (Model Context Protocol) 2025-11-25 specification and how to use them with the `mcp-oauth` library.

## Table of Contents

1. [What's New in MCP 2025-11-25](#whats-new-in-mcp-2025-11-25)
2. [Migration from Previous Versions](#migration-from-previous-versions)
3. [Feature Guide](#feature-guide)
4. [Security Considerations](#security-considerations)
5. [Testing and Validation](#testing-and-validation)

## What's New in MCP 2025-11-25

The MCP 2025-11-25 specification introduces several enhancements to improve OAuth discovery, scope management, and security:

### 1. Protected Resource Metadata Discovery (RFC 9728)

Standardized discovery mechanism for finding authorization servers and understanding scope requirements.

- **Endpoint**: `/.well-known/oauth-protected-resource`
- **Purpose**: Helps clients discover authorization server and required scopes
- **Status**: **REQUIRED** by MCP 2025-11-25

### 2. WWW-Authenticate Header Enhancements (RFC 6750 Section 3)

Enhanced 401 responses with discovery information and scope guidance.

- **Parameters**: `resource_metadata`, `scope`, `error`, `error_description`
- **Purpose**: Provides clients with actionable guidance on how to authenticate
- **Status**: **REQUIRED** by MCP 2025-11-25

### 3. Scope Selection Strategy

Standardized approach for clients to determine which scopes to request.

- **Priority Order**: 
  1. Use `scope` parameter from WWW-Authenticate header (if provided)
  2. Use all scopes from `scopes_supported` in Protected Resource Metadata
- **Status**: **RECOMMENDED** behavior for clients

### 4. Resource Parameter (RFC 8707)

Token audience binding using resource indicators.

- **Purpose**: Bind access tokens to specific resource servers
- **Benefits**: Prevents token misuse across different resources
- **Status**: **OPTIONAL** but recommended for multi-resource deployments

### 5. Client ID Metadata Documents

Dynamic client metadata discovery for distributed authentication.

- **Purpose**: Allow distributed verification of client configurations
- **Use Case**: Federation scenarios, client trust verification
- **Status**: **OPTIONAL**

### 6. Insufficient Scope Error Handling

Standardized error response when token lacks required scopes.

- **Error Code**: `insufficient_scope`
- **Response**: Includes required scopes in error response and WWW-Authenticate header
- **Purpose**: Enables step-up authorization flows
- **Status**: **REQUIRED** by MCP 2025-11-25

## Migration from Previous Versions

### Breaking Changes

**None!** All MCP 2025-11-25 features are backward compatible and opt-in by default.

### Compatibility Mode

If you have legacy OAuth clients that cannot handle enhanced WWW-Authenticate headers:

```go
&server.Config{
    // Disable enhanced WWW-Authenticate headers for backward compatibility
    DisableWWWAuthenticateMetadata: true,
}
```

**Note**: This is rarely needed. Modern OAuth clients ignore unknown parameters per HTTP specifications.

### Recommended Migration Path

1. **Enable discovery endpoints** (enabled by default)
2. **Configure scopes** (add `SupportedScopes` and `DefaultChallengeScopes`)
3. **Add endpoint scope requirements** (optional, for fine-grained access control)
4. **Test with MCP clients** (verify discovery and scope selection work)
5. **Monitor logs** (check for any client compatibility issues)

## Feature Guide

### 1. Protected Resource Metadata Discovery

#### Basic Setup

The library automatically exposes Protected Resource Metadata endpoints when you register routes:

```go
import (
    oauth "github.com/giantswarm/mcp-oauth"
)

func main() {
    // ... create server ...
    
    handler := oauth.NewHandler(server, nil)
    mux := http.NewServeMux()
    
    // Register Protected Resource Metadata endpoints
    // This creates both root and sub-path discovery endpoints
    handler.RegisterProtectedResourceMetadataRoutes(mux, "/mcp")
    
    // Your protected MCP endpoints
    mux.Handle("/mcp", handler.ValidateToken(yourMCPHandler))
    
    http.ListenAndServe(":8080", mux)
}
```

This automatically creates:
- `/.well-known/oauth-protected-resource` - Root discovery
- `/mcp/.well-known/oauth-protected-resource` - Sub-path discovery (MCP 2025-11-25)

#### Example Discovery Response

```json
{
  "resource": "https://your-server.com",
  "authorization_servers": [
    "https://your-server.com"
  ],
  "scopes_supported": [
    "mcp:access",
    "files:read",
    "files:write"
  ],
  "bearer_methods_supported": [
    "header"
  ]
}
```

#### Client Discovery Flow

```bash
# Step 1: Client makes unauthorized request
curl https://your-server.com/mcp

# Response: 401 Unauthorized
# WWW-Authenticate: Bearer resource_metadata="https://your-server.com/.well-known/oauth-protected-resource"

# Step 2: Client fetches metadata
curl https://your-server.com/.well-known/oauth-protected-resource

# Step 3: Client discovers authorization server
curl https://your-server.com/.well-known/oauth-authorization-server

# Step 4: Client initiates OAuth flow with discovered endpoints
```

### 2. WWW-Authenticate Header Enhancements

#### Configuration

```go
&server.Config{
    Issuer: "https://your-server.com",
    
    // Configure scopes to advertise in 401 challenges
    DefaultChallengeScopes: []string{"mcp:access", "files:read"},
    
    // List all supported scopes for discovery
    SupportedScopes: []string{
        "mcp:access",
        "files:read",
        "files:write",
        "user:profile",
    },
    
    // Enhanced WWW-Authenticate headers are enabled by default
    // DisableWWWAuthenticateMetadata: false, // (default: false = enabled)
}
```

#### Example 401 Response

```http
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Bearer resource_metadata="https://your-server.com/.well-known/oauth-protected-resource",
                         scope="mcp:access files:read",
                         error="invalid_token",
                         error_description="Token has expired"
Content-Type: application/json

{
  "error": "invalid_token",
  "error_description": "Token has expired"
}
```

### 3. Scope Selection Strategy

#### Server Configuration

The library supports both default scopes and endpoint-specific scopes:

```go
&server.Config{
    // Default scopes for general access
    DefaultChallengeScopes: []string{"mcp:access"},
    
    // Endpoint-specific scope requirements (path-based)
    EndpointScopeRequirements: map[string][]string{
        "/api/files/*":   {"files:read", "files:write"},
        "/api/admin/*":   {"admin:access"},
    },
    
    // Method-specific scope requirements (path + HTTP method)
    EndpointMethodScopeRequirements: map[string]map[string][]string{
        "/api/files/*": {
            "GET":    {"files:read"},
            "POST":   {"files:write"},
            "DELETE": {"files:delete", "admin:access"},
        },
    },
}
```

#### Client Behavior (MCP 2025-11-25)

Clients following MCP 2025-11-25 **SHOULD** use this priority order for scope selection:

1. **Use `scope` parameter** from WWW-Authenticate header (most specific)
2. **Use `scopes_supported`** from Protected Resource Metadata (general)

#### Endpoint-Specific Scopes in WWW-Authenticate

When you configure `EndpointScopeRequirements`, the library automatically includes endpoint-specific scopes in 401 responses:

```http
GET /api/files/document.txt HTTP/1.1

HTTP/1.1 401 Unauthorized
WWW-Authenticate: Bearer resource_metadata="...",
                         scope="files:read files:write",
                         error="invalid_token"
```

This tells the client exactly which scopes are needed for this specific endpoint.

### 4. Resource Parameter (RFC 8707)

#### What is the Resource Parameter?

The `resource` parameter binds access tokens to specific resource servers, preventing token misuse across different services.

#### Configuration

```go
&server.Config{
    Issuer: "https://auth.example.com",
    
    // Enable resource parameter validation
    // Tokens will be bound to specific resource servers
    AllowResourceParameter: true,
    
    // Optional: Configure allowed resource servers
    AllowedResources: []string{
        "https://files.example.com",
        "https://api.example.com",
    },
}
```

#### Client Usage

Clients include the `resource` parameter in authorization requests:

```http
POST /oauth/authorize
Content-Type: application/x-www-form-urlencoded

response_type=code
&client_id=client123
&redirect_uri=https://client.example.com/callback
&resource=https://files.example.com
&scope=files:read
```

The resulting access token will only be valid for `https://files.example.com`.

#### Token Validation

The library automatically validates the `resource` claim during token validation:

```go
// Token validation automatically checks resource binding
mux.Handle("/api/files", handler.ValidateToken(filesHandler))

// If token was issued for different resource, validation fails with:
// HTTP 401 + error="invalid_token", error_description="Token not valid for this resource"
```

#### Security Benefits

- **Token Scope Limitation**: Tokens can't be reused across different resource servers
- **Lateral Movement Prevention**: Compromised token for one service can't access others
- **Compliance**: Supports zero-trust security architectures

### 5. Client ID Metadata Documents

#### What are Client ID Metadata Documents?

Client ID Metadata Documents allow distributed verification of client configurations using HTTPS URIs as client IDs.

#### Configuration

```go
&server.Config{
    // Enable Client ID Metadata Document support
    EnableClientIDMetadata: true,
    
    // Configure caching to reduce external requests
    ClientIDMetadataCacheTTL: 3600, // 1 hour
    
    // Configure timeout for fetching metadata
    ClientIDMetadataFetchTimeout: 5, // 5 seconds
}
```

#### Client Registration with Metadata URL

```bash
curl -X POST https://your-server.com/oauth/register \
  -H "Content-Type: application/json" \
  -d '{
    "client_id": "https://client.example.com/.well-known/client-configuration",
    "redirect_uris": ["https://client.example.com/callback"]
  }'
```

#### Metadata Document Format

```json
{
  "client_id": "https://client.example.com/.well-known/client-configuration",
  "client_name": "Example MCP Client",
  "redirect_uris": [
    "https://client.example.com/callback",
    "https://client.example.com/oauth/callback"
  ],
  "grant_types": ["authorization_code", "refresh_token"],
  "token_endpoint_auth_method": "none",
  "logo_uri": "https://client.example.com/logo.png",
  "policy_uri": "https://client.example.com/privacy",
  "tos_uri": "https://client.example.com/terms"
}
```

#### Security Considerations

See [Client ID Metadata Documents Security](#client-id-metadata-documents-security) section below.

### 6. Insufficient Scope Error Handling

#### Automatic Scope Validation

When you configure `EndpointScopeRequirements`, the library automatically validates token scopes:

```go
&server.Config{
    EndpointScopeRequirements: map[string][]string{
        "/api/admin/*": {"admin:access"},
    },
}
```

#### Example Error Response

```http
GET /api/admin/users HTTP/1.1
Authorization: Bearer <token-with-only-basic-scopes>

HTTP/1.1 403 Forbidden
WWW-Authenticate: Bearer scope="admin:access",
                         error="insufficient_scope",
                         error_description="Token lacks required scopes"
Content-Type: application/json

{
  "error": "insufficient_scope",
  "error_description": "Token lacks required scopes: admin:access",
  "scope": "admin:access"
}
```

#### Step-Up Authorization Flow

Clients can implement step-up authorization when they receive `insufficient_scope`:

1. Client requests resource with basic token
2. Server returns 403 with `insufficient_scope` and required scopes
3. Client initiates new authorization flow with additional scopes
4. Client retries request with new, more privileged token

```go
// Client pseudocode
func accessAdminEndpoint() error {
    resp := GET("/api/admin/users", token)
    
    if resp.StatusCode == 403 && resp.Error == "insufficient_scope" {
        // Step-up: Request additional scopes
        requiredScopes := resp.Scope
        newToken := requestAuthorization(currentScopes + requiredScopes)
        
        // Retry with new token
        resp = GET("/api/admin/users", newToken)
    }
    
    return handleResponse(resp)
}
```

## Security Considerations

### Protected Resource Metadata Discovery

**Information Disclosure**: The metadata endpoint is intentionally public and discoverable. This is required by OAuth/MCP specifications for proper client discovery.

**Mitigation**: 
- Only include general scopes in `scopes_supported`, not sensitive internal scopes
- Don't expose internal service names or implementation details
- Monitor metadata endpoint access logs for reconnaissance attempts

### WWW-Authenticate Headers

**Scope Enumeration**: Attackers can trigger 401 responses to discover available scopes.

**Mitigation**:
- Use broad, general scopes in `DefaultChallengeScopes` (e.g., `"mcp:access"` not `"internal:admin:full_access"`)
- Configure endpoint-specific scopes carefully
- Monitor for unusual patterns in 401 responses (rate limiting helps)

**Recommendation**: This is an acceptable trade-off - the discovery benefit for legitimate clients outweighs the minor information disclosure.

### Resource Parameter Security

**Token Binding**: Resource parameter provides strong security benefits by limiting token scope.

**Best Practices**:
- Use specific, well-defined resource URIs (e.g., `"https://files.example.com"` not `"https://*.example.com"`)
- Validate resource parameter matches the intended service
- Consider requiring resource parameter for high-security deployments
- Monitor for tokens used against wrong resource servers

**SSRF Protection**: The library doesn't fetch resource URLs, so there's no SSRF risk from this feature.

### Client ID Metadata Documents Security

**SSRF (Server-Side Request Forgery) Risk**: Fetching client metadata from arbitrary URLs could expose internal services.

**Mitigations Implemented**:
- Only HTTPS URLs allowed (no HTTP, file://, etc.)
- Configurable timeout prevents long-running requests
- Caching reduces frequency of external requests
- Response size limits prevent memory exhaustion
- Request validation prevents malicious URLs

**Additional Recommendations**:
- Use network egress filtering to limit which external hosts can be contacted
- Monitor for unusual metadata fetch patterns
- Consider allowlisting trusted client domains
- Set conservative cache TTL to balance security vs performance

**Example Secure Configuration**:

```go
&server.Config{
    EnableClientIDMetadata: true,
    ClientIDMetadataCacheTTL: 1800,        // 30 minutes
    ClientIDMetadataFetchTimeout: 3,       // 3 seconds (short timeout)
    ClientIDMetadataMaxSize: 10240,        // 10KB max response
    
    // Optional: Use allowlist for production
    AllowedClientIDDomains: []string{
        "client.example.com",
        "trusted-partner.com",
    },
}
```

### Insufficient Scope Handling

**Information Disclosure**: Error responses reveal required scopes for protected endpoints.

**Mitigation**:
- This is intentional and required by OAuth 2.0 specifications
- Helps legitimate clients understand access requirements
- Monitor for scope enumeration attempts via rate limiting
- Use coarse-grained scopes when possible

**Security Benefit**: Prevents unauthorized access while providing clear feedback to legitimate clients.

## Testing and Validation

### Test Discovery Endpoints

```bash
# Test root Protected Resource Metadata
curl -i https://your-server.com/.well-known/oauth-protected-resource

# Test sub-path discovery (MCP 2025-11-25)
curl -i https://your-server.com/mcp/.well-known/oauth-protected-resource

# Test Authorization Server Metadata
curl -i https://your-server.com/.well-known/oauth-authorization-server
```

### Test WWW-Authenticate Headers

```bash
# Test 401 response format
curl -i https://your-server.com/mcp

# Verify headers include:
# - resource_metadata parameter
# - scope parameter (if configured)
# - error and error_description
```

### Test Scope Validation

```bash
# Test with insufficient scopes
# Should return 403 with insufficient_scope error
curl -i -H "Authorization: Bearer <token-with-basic-scopes>" \
    https://your-server.com/api/admin/users

# Test with sufficient scopes  
# Should return 200 OK
curl -i -H "Authorization: Bearer <token-with-admin-scope>" \
    https://your-server.com/api/admin/users
```

### Test Resource Parameter

```bash
# Test token bound to specific resource
# Token issued with resource=https://files.example.com
# Should succeed:
curl -i -H "Authorization: Bearer <token>" \
    https://files.example.com/api/document

# Should fail (token bound to different resource):
curl -i -H "Authorization: Bearer <token>" \
    https://api.example.com/users
```

### Validate MCP 2025-11-25 Compliance

Use this checklist to ensure full compliance:

- [ ] Protected Resource Metadata endpoint returns valid JSON
- [ ] `scopes_supported` includes all available scopes
- [ ] `authorization_servers` points to correct authorization server
- [ ] Sub-path discovery works (e.g., `/mcp/.well-known/oauth-protected-resource`)
- [ ] 401 responses include `resource_metadata` in WWW-Authenticate
- [ ] 401 responses include `scope` parameter (if configured)
- [ ] 403 responses use `insufficient_scope` error code
- [ ] Scope validation works correctly
- [ ] All discovery endpoints are accessible via HTTPS

## See Also

- [Discovery Mechanisms Documentation](./discovery.md)
- [Security Architecture](../SECURITY_ARCHITECTURE.md)
- [MCP Specification 2025-11-25](https://modelcontextprotocol.io/specification/2025-11-25/basic/authorization)
- [RFC 6750 - Bearer Token Usage](https://datatracker.ietf.org/doc/html/rfc6750)
- [RFC 8707 - Resource Indicators](https://datatracker.ietf.org/doc/html/rfc8707)
- [RFC 9728 - Protected Resource Metadata](https://datatracker.ietf.org/doc/html/rfc9728)

